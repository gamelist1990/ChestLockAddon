<!DOCTYPE html>
<html>

<head>
    <title>WebVC</title>
    <meta charset="utf-8">
    <style>
        body {
            font-family: sans-serif;
        }

        h1 {
            text-align: center;
        }

        div {
            margin: 10px;
        }

        #userList {
            list-style: none;
            padding: 0;
        }

        #userList li {
            margin-bottom: 5px;
        }

        #log {
            border: 1px solid #ccc;
            padding: 5px;
            height: 200px;
            overflow-y: scroll;
        }
    </style>
</head>

<body>
    <h1>WebVC</h1>

    <div>
        <label for="username">ユーザー名:</label>
        <select id="username"></select>
        <button id="connectBtn">接続</button>
        <button id="disconnectBtn" disabled>切断</button>
    </div>

    <div>
        <h2>近くのユーザー:</h2>
        <ul id="userList"></ul>
    </div>

    <div>
        <h2>ログ:</h2>
        <div id="log"></div>
    </div>

    <script>
        const usernameSelect = document.getElementById('username');
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const userList = document.getElementById('userList');
        const logDiv = document.getElementById('log');

        let socket;
        let mediaRecorder;
        let audioContext;
        const CHUNK_SIZE = 20 * 48000 / 1000; // 20ms分のサンプル数 (サンプルレート48kHzを想定)
        let audioQueue = [];
        let playing = false;


        window.addEventListener('load', async () => {
            await fetchPlayerList();
        });

        connectBtn.addEventListener('click', () => {
            const username = usernameSelect.value;
            if (username) {
                if (!audioContext) {
                    audioContext = new AudioContext();
                }

                connectWebSocket(username);
                connectBtn.disabled = true;
                disconnectBtn.disabled = false;
            } else {
                logMessage('ユーザー名を選択してください');
            }
        });

        disconnectBtn.addEventListener('click', () => {
            if (socket) {
                socket.close();
            }
        });

        async function fetchPlayerList() {
            try {
                const response = await fetch(`/playerList`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                updatePlayerSelect(data.players);
            } catch (error) {
                console.error('プレイヤーリストの取得に失敗しました:', error);
                logMessage('プレイヤーリストの取得に失敗しました');
            }
        }

        function updatePlayerSelect(players) {
            usernameSelect.innerHTML = '';
            players.forEach(player => {
                const option = document.createElement('option');
                option.value = player;
                option.textContent = player;
                usernameSelect.appendChild(option);
            });
        }

        function updateUserList(users) {
            userList.innerHTML = '';
            users.forEach(user => {
                const li = document.createElement('li');
                li.textContent = `${user.username} (距離: ${user.distance.toFixed(2)})`;
                userList.appendChild(li);
            });
        }

        function logMessage(message) {
            const p = document.createElement('p');
            p.textContent = message;
            logDiv.appendChild(p);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function connectWebSocket(username) {
            const serverUrl = `ws://localhost:19134/?username=${username}`;
            socket = new WebSocket(serverUrl);
            socket.binaryType = 'arraybuffer';

            socket.addEventListener('open', () => {
                logMessage('サーバーに接続しました');
                startRecording();
                socket.send(JSON.stringify({ type: 'getPlayerList' }));
            });

            socket.addEventListener('message', (event) => {
                console.log("Received data type:", event.data.constructor.name);

                if (event.data instanceof ArrayBuffer) {
                    console.log("Received PCM audio data:", event.data.byteLength, "bytes");
                    audioQueue.push(event.data);
                    if (!playing) {
                        playFromQueue();
                    }
                } else if (typeof event.data === 'string') {
                    try {
                        const data = JSON.parse(event.data);

                        if (data.type === 'playerList') {
                            updatePlayerSelect(data.players);
                        } else if (data.type === 'userList') {
                            updateUserList(data.users);
                        } else if (data.type === 'voice') {
                            console.warn("Received 'voice' message with string data. Expected ArrayBuffer.");
                            logMessage("不正な音声データを受信しました。");
                        } else if (data.type === 'log') {
                            logMessage(data.message);
                        } else {
                            console.warn("Received unknown message type:", data.type);
                        }
                    } catch (error) {
                        console.error('Error parsing message:', error);
                        logMessage("メッセージのパース中にエラーが発生しました。");
                    }
                } else {
                    console.error("Received unexpected data type:", typeof event.data);
                    logMessage("予期しないデータ型を受信しました。");
                }
            });

            socket.addEventListener('close', () => {
                logMessage('サーバーから切断しました');
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
                userList.innerHTML = '';
                stopRecording();
            });

            socket.addEventListener('error', (error) => {
                console.error('WebSocket エラー:', error);
                logMessage('エラーが発生しました');
            });
        }

        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=pcm' });

                mediaRecorder.addEventListener('dataavailable', (event) => {
                    if (event.data.size > 0) {
                        sendAudio(event.data);
                    }
                });

                mediaRecorder.start(20); // 20msごとにデータを送信
            } catch (error) {
                console.error('マイクアクセスエラー:', error);
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    logMessage('マイクへのアクセスが拒否されました。ブラウザの設定を確認してください。');
                } else if (error.name === 'NotFoundError') {
                    logMessage('マイクが見つかりません。');
                } else {
                    logMessage('マイクへのアクセス中にエラーが発生しました。');
                }
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
        }

        function sendAudio(audioBlob) {
            audioBlob.arrayBuffer().then(arrayBuffer => {
                if (socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(arrayBuffer);
                }
            });
        }

        function playFromQueue() {
            if (!playing && audioQueue.length > 0) {
                playing = true;
                let audioData = audioQueue.shift();

                // バイト数が2の倍数でない場合の処理
                const remainder = audioData.byteLength % 2;
                if (remainder !== 0) {
                    console.warn("Received audio data with odd byte length. Truncating last byte.");
                    const truncatedData = audioData.slice(0, audioData.byteLength - remainder); // 余分なバイトを切り捨て
                    audioData = truncatedData; // audioData を更新
                }



                const buffer = audioContext.createBuffer(1, audioData.byteLength / 2, audioContext.sampleRate);
                const pcmSamples = new Int16Array(audioData); // ここでのエラーを回避
                const floatSamples = new Float32Array(pcmSamples.length);

                for (let i = 0; i < pcmSamples.length; i++) {
                    floatSamples[i] = pcmSamples[i] / 32768;
                }

                buffer.copyToChannel(floatSamples, 0);


                const source = audioContext.createBufferSource();
                source.buffer = buffer;
                source.connect(audioContext.destination);
                source.start();

                source.onended = () => {
                    playing = false;
                    playFromQueue();
                };
            }
        }
    </script>
</body>

</html>
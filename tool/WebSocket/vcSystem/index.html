<!DOCTYPE html>
<html>

<head>
    <title>WebVC</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
            -webkit-text-size-adjust: 100%;
            /* iOSでのテキストサイズ自動調整を無効化 */
        }

        label {
            display: block;
            margin-bottom: 5px;
        }

        button {
            margin: 10px 5px;
            padding: 8px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            /* タップ時のハイライトを無効化 */
        }

        button:disabled {
            background-color: #cccccc;
            cursor: default;
        }

        ul {
            list-style: none;
            padding: 0;
        }

        li {
            margin-bottom: 5px;
        }

        #log {
            border: 1px solid #ccc;
            height: 200px;
            overflow-y: scroll;
            padding: 10px;
            -webkit-overflow-scrolling: touch;
            /* iOSでのスムーズスクロール */
        }

        /* iPhoneのランドスケープモードでのスタイル */
        @media only screen and (max-width: 768px) and (orientation: landscape) {
            body {
                margin: 10px;
            }

            #log {
                height: 150px;
            }
        }
    </style>
</head>

<body>
    <h1>WebVC</h1>
    <p>ミュート中は自分の声が聞こえるようにしてあります()</p>
    <div>
        <label for="username">ユーザー名:</label>
        <select id="username"></select>
        <button id="connectBtn">接続</button>
        <button id="disconnectBtn" disabled>切断</button>
        <button id="muteBtn">ミュート</button>
    </div>

    <div>
        <h2>近くのユーザー:</h2>
        <ul id="userList"></ul>
    </div>

    <div>
        <h2>ログ:</h2>
        <div id="log"></div>
    </div>

    <script>
        const usernameSelect = document.getElementById('username');
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const muteBtn = document.getElementById('muteBtn');
        const userList = document.getElementById('userList');
        const logDiv = document.getElementById('log');

        let socket;
        let mediaRecorder;
        let audioContext;
        let sendAudioQueue = [];
        let receiveAudioQueue = [];
        let isSending = false;
        let intervalId;
        let isMuted = false; 

        // ミュートボタンのイベントリスナー
        muteBtn.addEventListener('click', () => {
            isMuted = !isMuted; // ミュート状態を切り替え
            muteBtn.textContent = isMuted ? 'ミュート解除' : 'ミュート'; // ボタンのテキストを更新
            logMessage(isMuted ? 'ミュートしました' : 'ミュート解除しました'); // ログにミュート状態を表示
        });

        window.addEventListener('load', async () => {
            await fetchPlayerList();
        });

        connectBtn.addEventListener('click', () => {
            const username = usernameSelect.value;
            if (username) {
                connectWebSocket(username);
                connectBtn.disabled = true;
                disconnectBtn.disabled = false;
            } else {
                logMessage('ユーザー名を選択してください');
            }
        });

        disconnectBtn.addEventListener('click', () => {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.addEventListener('close', () => {
                    stopRecording();
                    disconnectBtn.disabled = true;
                    connectBtn.disabled = false;
                    logMessage('サーバーから切断しました');
                    userList.innerHTML = '';
                    sendAudioQueue = [];
                    receiveAudioQueue = [];
                    isSending = false;
                    // isPlaying = false;
                }, { once: true });
                socket.close();
            } else {
                stopRecording();
                disconnectBtn.disabled = true;
                connectBtn.disabled = false;
                sendAudioQueue = [];
                receiveAudioQueue = [];
                isSending = false;
                // isPlaying = false;
            }
        });

        async function fetchPlayerList() {
            try {
                const response = await fetch(`/playerList`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                updatePlayerSelect(data.players);
            } catch (error) {
                console.error('プレイヤーリストの取得に失敗しました:', error);
                logMessage('プレイヤーリストの取得に失敗しました');
            }
        }

        function updatePlayerSelect(players) {
            usernameSelect.innerHTML = '';
            players.forEach(player => {
                const option = document.createElement('option');
                option.value = player;
                option.textContent = player;
                usernameSelect.appendChild(option);
            });
        }

        function updateUserList(users) {
            userList.innerHTML = '';
            users.forEach(user => {
                const li = document.createElement('li');

                // data-* 属性を使って、ユーザー名とボリュームを要素に格納
                li.dataset.username = user.username;
                li.dataset.volume = user.volume;

                const usernameSpan = document.createElement('span');
                usernameSpan.textContent = `${user.username} `;
                li.appendChild(usernameSpan);

                // ユーザー名の後に距離を括弧で追加
                const distanceSpan = document.createElement('span');
                distanceSpan.textContent = `(距離: ${user.distance.toFixed(2)})`;
                li.appendChild(distanceSpan);

                // 距離の後に音量を表示
                const volumeSpan = document.createElement('span');
                volumeSpan.textContent = `, 音量: ${user.volume.toFixed(2)}`;
                li.appendChild(volumeSpan);

                userList.appendChild(li);

            });
        }

        function logMessage(message) {
            const p = document.createElement('p');
            p.textContent = message;
            logDiv.appendChild(p);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function connectWebSocket(username) {
            const serverUrl = `wss://bfxmknk4-19133.asse.devtunnels.ms/?username=${username}`;
            socket = new WebSocket(serverUrl, "binary");
            socket.binaryType = 'arraybuffer';

            socket.addEventListener('open', (event) => {
                logMessage(`${username}でサーバーに接続しました`);
                startRecording();
            });

            socket.addEventListener('message', (event) => {
                if (event.data instanceof ArrayBuffer) {
                    // event.data をそのまま receiveAudioQueue に追加
                    const messageData = { username: null, audioData: event.data };
                    receiveAudioQueue.push(messageData);
                } else {
                    try {
                        const data = JSON.parse(event.data);

                        // サーバーからのメッセージをログに表示

                        if (data.type === 'playerList') {
                            updatePlayerSelect(data.players);
                        } else if (data.type === 'userList') {
                            updateUserList(data.users);
                        }
                    } catch (error) {
                        console.error("Error parsing JSON:", error);
                    }
                }
            });

            socket.addEventListener('close', (event) => {
                logMessage('サーバーから切断しました');
                if (event.code === 1008) {
                    if (event.reason === "Username is required") {
                        logMessage("エラー: ユーザー名が指定されていません。");
                    } else if (event.reason === "Username already connected") {
                        logMessage("エラー: このユーザー名は既に使用されています。");
                    } else {
                        logMessage("エラー: サーバーとの接続に問題があります。(ユーザー名関連)")
                    }
                } else if (event.code === 1000) {
                    logMessage("正常に切断しました。");
                }
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
                userList.innerHTML = '';
                sendAudioQueue = [];
                receiveAudioQueue = [];
                isSending = false;
                // isPlaying = false;
            });

            socket.addEventListener('error', (error) => {
                console.error('WebSocket エラー:', error);
                logMessage('エラーが発生しました');
                stopRecording();
            });
        }

        async function startRecording() {
            try {
                // マイクの許可を求める(httpsであれば不要)
                if (navigator.mediaDevices.getUserMedia) {
                    const permission = await navigator.permissions.query({ name: 'microphone' });
                    if (permission.state !== 'granted') {
                        await navigator.mediaDevices.getUserMedia({ audio: true });
                    }
                }

                const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true } });
                if (!audioContext) {
                    audioContext = new AudioContext();
                }

                // 型付き配列のテストとmediaRecorderの設定(型付き配列は意味がないと思うので消去)
                const mimeType = "audio/webm;codecs=opus";
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    console.error("audio/webm;codecs=opus is not supported");
                    return;
                }

                if (mediaRecorder) {
                    mediaRecorder.stop();
                    mediaRecorder.ondataavailable = null;
                }

                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: mimeType,
                    audioBitsPerSecond: 64000
                });

                //128000 高
                //64000 通常

                // mediaRecorderのスタートと再スタートの設定
                mediaRecorder.ondataavailable = async (event) => {
                    handleLocalAudioData(event);
                };

                mediaRecorder.start(1000);
                intervalId = setInterval(restartRecording, 1000);

            } catch (error) {
                console.error('Error accessing media devices:', error);
                logMessage('マイクへのアクセス中にエラーが発生しました。');
            }
        }

        const restartRecording = () => {
            if (mediaRecorder && mediaRecorder.state !== "inactive") {
                mediaRecorder.stop();
            }

            mediaRecorder = new MediaRecorder(mediaRecorder.stream, {
                mimeType: mediaRecorder.mimeType,
                audioBitsPerSecond: mediaRecorder.audioBitsPerSecond
            });
            mediaRecorder.ondataavailable = handleLocalAudioData;
            mediaRecorder.start(1000);
        };

        async function handleLocalAudioData(event) {
            // ミュート状態がtrueの場合は、データの送信をスキップ
            if (isMuted) return;
            const minDataSize = 1000;
            if (event.data.size > minDataSize) {
                const reader = new FileReader();
                reader.onload = () => {
                    const arrayBuffer = reader.result;
                    const uint8Array = new Uint8Array(arrayBuffer);
                };
                reader.readAsArrayBuffer(event.data);

                sendAudioQueue.push(event.data);
            }
        }

        async function processReceiveAudioQueue() {
            if (receiveAudioQueue.length === 0) {
                return;
            }

            const messageData = receiveAudioQueue.shift(); // キューからユーザー名と音声データを取り出す
            const audioData = messageData.audioData;

            // ここで userList から data-username と data-volume を探す
            let matchedUser = null;
            for (const li of userList.children) {
                if (li.dataset.username) {
                    matchedUser = li;
                    break;
                }
            }

            //マッチしたユーザーを探す
            if (matchedUser) {
                const username = matchedUser.dataset.username;
                const volume = parseFloat(matchedUser.dataset.volume);

                try {
                    // オーディオを再生（ボリュームを渡す）
                    console.log("ユーザー名とボリューム", username, volume);
                    await playAudio(audioData, volume);
                } catch (error) {
                    console.error("Error playing audio:", error);
                }
            }
        }

        async function sendAudioData(eventData) {
            if (socket && socket.readyState === WebSocket.OPEN) {
                const arrayBuffer = await eventData.arrayBuffer();
                socket.send(arrayBuffer);
            } else {
                console.warn("WebSocket is not open. Unable to send audio data.");
            }
        }

        async function processSendAudioQueue() {
            if (isSending || sendAudioQueue.length === 0) {
                return;
            }

            isSending = true;
            const audioData = sendAudioQueue.shift();

            try {
                await sendAudioData(audioData);
            } catch (error) {
                console.error("Error sending audio:", error);
            } finally {
                isSending = false;
            }
        }

        setInterval(processSendAudioQueue, 100);
        setInterval(processReceiveAudioQueue, 100);

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            if (intervalId) {
                clearInterval(intervalId);
                intervalId = null;
            }
        }

        async function playAudio(arrayBuffer, volume) {
            try {
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                const gainNode = audioContext.createGain();

                // ボリューム情報をログに出力
                console.log("Playing audio with volume:", volume);

                gainNode.gain.value = volume;

                source.connect(gainNode);
                gainNode.connect(audioContext.destination);

                source.onended = () => {
                };

                source.start();
            } catch (e) {
                console.error('Error decoding or playing audio data:', e.message, e);
            }
        }
    </script>
</body>

</html>